# Hard Link & Soft Link

```bash
total 32
drwxr-x--- 1 user01 user01 4096  8월  8 09:42 ./
drwxr-xr-x 1 root   root   4096  8월  7 12:13 ../
-rw-r--r-- 1 user01 user01  220  8월  7 12:13 .bash_logout
-rw-r--r-- 1 user01 user01 3771  8월  7 12:13 .bashrc
-rw-r--r-- 1 user01 user01  807  8월  7 12:13 .profile
-rw-rw-r-- 2 user01 user01    6  8월  8 09:40 file1 # <- Original File
```

## Hard Link
- 하드 링크는 파일의 inode 번호를 공유하는 링크이다.

> **inode**: 파일의 메타데이터 정보를 저장하는 공간

- 하드 링크는 원본 파일과 링크 파일이 같은 inode 번호를 가지고 있기 때문에, 원본 파일과 링크 파일은 같은 파일로 인식된다.
- 원본 파일과 링크 파일은 같은 데이터를 가지고 있기 때문에, 하나의 파일을 수정하면 다른 파일도 수정된다.

```bash
$ ln file1 hardlink.txt
```

```bash
total 32
drwxr-x--- 1 user01 user01 4096  8월  8 09:42 ./
drwxr-xr-x 1 root   root   4096  8월  7 12:13 ../
-rw-r--r-- 1 user01 user01  220  8월  7 12:13 .bash_logout
-rw-r--r-- 1 user01 user01 3771  8월  7 12:13 .bashrc
-rw-r--r-- 1 user01 user01  807  8월  7 12:13 .profile
-rw-rw-r-- 2 user01 user01    6  8월  8 09:40 file1
-rw-rw-r-- 2 user01 user01    6  8월  8 09:40 hardlink.txt # <- Hard Link
```

## Symbolic Link (Soft Link)

- 심볼릭 링크는 파일의 경로를 가리키는 링크이다.
  - 바로가기와 비슷한 개념
- 심볼릭 링크는 원본 파일과 링크 파일이 다른 inode 번호를 가지고 있기 때문에, 원본 파일과 링크 파일은 다른 파일로 인식된다.
- 심볼릭 링크는 원본 파일의 경로를 가리키기 때문에, 원본 파일이 삭제되면 심볼릭 링크는 끊어진다.

```bash
$ ln -s file1 softlink.txt
# or
$ ln --symbolic file1 softlink.txt
```

```bash
total 32
drwxr-x--- 1 user01 user01 4096  8월  8 09:42 ./
drwxr-xr-x 1 root   root   4096  8월  7 12:13 ../
-rw-r--r-- 1 user01 user01  220  8월  7 12:13 .bash_logout
-rw-r--r-- 1 user01 user01 3771  8월  7 12:13 .bashrc
-rw-r--r-- 1 user01 user01  807  8월  7 12:13 .profile
-rw-rw-r-- 2 user01 user01    6  8월  8 09:40 file1
-rw-rw-r-- 1 user01 user01    6  8월  8 09:40 hardlink.txt
lrwxrwxrwx 1 user01 user01    6  8월  8 09:40 softlink.txt -> file1 # <- Soft Link
```

## 하드 링크와 심볼릭 링크의 차이점
  - 하드 링크
    - 원본 파일과 링크 파일은 같은 파일로 인식
    - 원본 파일을 수정하면 링크 파일도 수정
  - 심볼릭 링크
    - 원본 파일과 링크 파일은 다른 파일로 인식
    - 원본 파일을 삭제하면 링크 파일은 끊어짐

# inode

- **inode**: 파일의 메타데이터 정보를 저장하는 공간
  - 파일의 권한, 소유자, 그룹, 파일 크기, 생성 시간, 수정 시간, inode 번호 등의 정보를 저장
  - 파일의 데이터는 inode에 저장되지 않음
  - 파일의 데이터는 데이터 블록에 저장됨
- **inode 테이블**: inode의 정보를 저장하는 테이블
  - inode 테이블은 inode 번호와 데이터 블록의 매핑 정보를 저장
  - inode 테이블은 파일 시스템의 일부분

## inode 확인
  
```bash
$ ls -i
```

```bash
131072 file1
131072 hardlink.txt
131073 softlink.txt
```

- inode 번호는 파일의 메타데이터 정보를 저장하는 공간을 가리키는 번호
- inode 번호가 같은 파일은 같은 inode를 가지고 있음

# AWK Command 

> `awk` : 텍스트 데이터를 처리하는 명령어

- 텍스트 데이터를 행 단위로 처리
- 행 단위로 데이터를 분리하고, 필드 단위로 데이터를 처리
  - 행: 레코드
  - 필드: 컬럼

출력 형식: `awk [옵션] '패턴 {명령}' [파일]`

- **`-F`**: 필드 구분자 지정
- **`-v`**: 변수 지정
- **`NR`**: 레코드 번호
- **`NF`**: 필드 번호
- **`$0`**: 전체 레코드
- **`$1`**: 첫 번째 필드
- **`$2`**: 두 번째 필드

- `BEGIN` 블록은 파일의 첫 번째 줄을 처리하기 전에 실행되는 코드를 포함할 수 있다.
- `END` 블록은 모든 줄을 처리한 후에 실행되는 코드를 포함할 수 있다.

# `visudo` Command

> `visudo` : sudoers 파일을 수정하는 명령어

- `sudoers` 파일은 `sudo` 명령어를 사용할 수 있는 사용자와 명령어를 설정하는 파일
  - `/etc/sudoers` 파일을 수정하게 된다.
  
```bash
$ sudo visudo
```

- `visudo` 명령어를 사용하면 `sudoers` 파일을 수정할 수 있는 에디터가 실행된다.
  - 문법 상의 오류를 잡아주는 기능이 있음
  - `sudoers` 파일을 직접 수정하는 것은 위험할 수 있음

# set, env, export Command

- **`set`**: 셸 변수와 함수 목록을 출력
- **`env`**: 환경 변수 목록을 출력
- **`export`**: 환경 변수를 설정

> **셸 변수**: 셸 스크립트 안에서 사용하는 변수
> **환경 변수**: Linux 전체에서 사용하는 전역 변수
> 셸 변수와 환경 변수는 다른 변수

`export` 명령어를 사용하면 셸 변수를 환경 변수로 설정할 수 있다.

```bash
$ MY_VAR="hello"
$ export MY_VAR
```

# `source` Command

> `source` : 셸 스크립트를 실행하는 명령어

- `source` 명령어를 사용하면 셸 스크립트를 현재 셸에서 실행할 수 있다.
  - 새로운 셸을 실행하지 않고 셸 스크립트를 실행할 때 사용

# 특수 문자

- **`$`**: 변수를 참조할 때 사용
- **`#`**: 주석
- **`!`**: 특수 명령어
- **`&`**: 백그라운드 실행
- **`*`**: 와일드카드 **(여러 글자)**
- **`?`**: 와일드카드 **(한 글자)**
- **`|`**: 파이프
- **`[ ]`**: [괄 호 안 의 문자 중 하나] 
- **`;`**: 명령어 구분
  - `;`를 사용하면 여러 명령어를 한 줄에 작성할 수 있다.
  - `&&` 또는 `||`를 사용하면 여러 명령어를 순차적으로 실행할 수 있다.
    - `&&`: 앞의 명령어가 **성공하면** 뒤의 명령어를 실행
    - `||`: 앞의 명령어가 **실패**하면 뒤의 명령어를 실행
- **`' '`**: 문자열 **(변수 참조 불가능)**
- **`" "`**: 문자열 (변수 참조 가능)

# STDIN, STDOUT, STDERR
## >, >>, 2>, 2>>

- **`>`**: 출력 리다이렉션 Overwrite
  - 명령어의 출력을 파일로 저장
  - 파일이 이미 존재하면 덮어쓰기
- **`>>`**: 출력 리다이렉션 Append
  - 명령어의 출력을 파일로 저장
  - 파일이 이미 존재하면 이어쓰기
- **`2>`**: 에러 리다이렉션 Overwrite
- **`2>>`**: 에러 리다이렉션 Append

> 에러 메시지는 STDERR로 출력되기 때문에, 에러 메시지를 파일로 저장할 때는 `2>` 또는 `2>>`를 사용해야 한다.

## <, << Command

- **`<`**: 입력 리다이렉션
  - 파일의 내용을 명령어의 입력으로 사용
- **`<<`**: Here Document
  - 명령어의 입력으로 사용할 여러 줄의 텍스트를 지정

## File Descriptor

- **`0`**: STDIN
- **`1`**: STDOUT
- **`2`**: STDERR
- **`>`**: STDOUT 리다이렉션
- **`2>`**: STDERR 리다이렉션
- **`&>`**: STDOUT과 STDERR 리다이렉션
- **`&>>`**: STDOUT과 STDERR 리다이렉션 Append
- **`2>&1`**: STDERR를 STDOUT으로 리다이렉션
- **`1>&2`**: STDOUT을 STDERR로 리다이렉션

# `tee` Command

> `tee` : 파일로 출력하는 명령어

- `tee` 를 사용하면 명령어의 출력을 파일로 저장하면서 화면에 출력할 수 있다.

```bash
$ ls | tee file.txt
```

# `xargs` Command

> `xargs` : 명령어의 출력을 다른 명령어의 입력으로 사용하는 명령어

보통은 `xargs` 명령어를 사용하여 다른 명령어의 입력으로 사용한다.

```bash
$ ls | xargs rm
```

위 명령어는 `ls` 명령어의 출력을 `rm` 명령어의 입력으로 사용한다.
(파일을 삭제)


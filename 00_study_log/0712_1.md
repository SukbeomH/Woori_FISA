# Functions Continue

## Docstring
- 함수의 사용법, 함수의 기능, 함수의 return 값 등을 설명하는 것

```python
def my_function():
    """
    함수의 기능을 설명하는 docstring
    """
    pass
```

- 함수의 이름을 호출하고, `shift` + `tab` 키를 누르면 docstring을 볼 수 있다.
- 작성할때 주의할 점
    - 함수의 첫 줄에 작성
    - 여러 줄로 작성할 수 있다.
    - PEP 8에 따라 """ """ 사용 권장

parameter와 return 값에 대한 설명을 추가할 수 있다.
- parameter의 자료형을 지정하기 위해서는 `: 자료형`을 추가한다.
- return 값의 자료형을 지정하기 위해서는 `-> 자료형`을 추가한다.

```python
def my_function(a: int, b: int) -> int:
    """
    함수의 기능을 설명하는 docstring
    """
    pass
```

**자료형을 지정하더라도 지정된 자료형을 강제하는 것은 아니다. 단지, 코드를 읽는 사람에게 정보를 제공할 뿐이다.**

## 함수 호출 구조
- 함수는 호출되어야 실행된다.
- 함수를 호출하는 방법
    - 함수명()
    - 함수명(인자1, 인자2, ...)
    - 변수 = 함수명()
    - 변수 = 함수명(인자1, 인자2, ...)

#### 실행이 된다는 것은?
- 메모리에 함수의 코드 블록이 올라가고, 실행된다.
  - 메모리에 함수를 위한 공간이 생성된다.
  - 이를 `call stack`이라고 한다.
  - 함수가 실행되면 `call stack`에 쌓이고, 종료되면 `call stack`에서 제거된다.
  - 함수는 함수만의 고유 공간을 가지고 있기 때문에, 함수 내에서 선언된 변수는 함수 내에서만 사용된다.
  - 함수가 종료되면 함수 내에서 선언된 변수는 메모리에서 제거된다.
- 함수가 호출되면 함수의 코드 블록이 실행되고, return 값이 있으면 return 값을 반환한다.
  - return 값이 없으면 `None`을 반환한다.
  - 반환과 함께 함수는 종료된다.
  - 종료될 때, 함수 내에서 선언된 변수는 메모리에서 제거된다
- 함수가 종료되면 함수의 코드 블록이 메모리에서 제거된다.

#### local variable :: 함수 내에서 선언된 변수
- 함수 내에서 선언된 변수는 함수 내에서만 사용된다.
- 함수가 종료되면 함수 내에서 선언된 변수는 메모리에서 제거된다.
- 함수 내에서 선언된 변수는 함수가 실행될 때마다 메모리에 새로 생성된다.

#### global variable :: 함수 밖에서 선언된 변수
- 함수 밖에서 선언된 변수는 프로그램 전체에서 사용된다.
- 함수 내에서 global variable을 사용할 수 있지만, global variable을 수정할 수는 없다.
- 함수 내에서 global variable을 수정하려면 `global` 키워드를 사용해야 한다.

```python
a = 1

def my_function():
    global a
    a = 2
    print(a)

my_function()
print(a)
```

- 전역변수의 경우 함수 내에서 수정이 되면 함수 밖에서도 수정된 값이 유지된다.
- 전역변수는 함수가 종료되어도 메모리에 남아있다.

> scope : 변수가 사용 가능한 범위
> - local scope : 함수 내에서 선언된 변수
> - global scope : 함수 밖에서 선언된 변수
> - built-in scope : 파이썬이 제공하는 변수
> - local scope -> global scope -> built-in scope 순으로 변수를 찾는다.
> - 변수명을 중복해서 사용하면 가장 먼저 찾은 변수를 사용한다.

## 재귀 함수
- 함수가 자기 자신을 호출하는 함수
- 재귀 함수는 반복문을 사용하지 않고 반복적인 작업을 수행할 수 있다.
- 재귀 함수는 반복문보다 코드가 간결하다.
- 재귀 함수는 종료 조건이 있어야 한다.

```python
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)

factorial(5)
```


## lambda 함수
- 인스턴스를 생성하지 않고 함수를 생성할 수 있다.
- 이름이 없는 함수
- 한 줄로 함수를 표현할 수 있다.
- lambda 인자 : 표현식

```python
lambda x, y: x + y
```

- lambda 함수는 변수에 할당해서 사용할 수 있다.

```python
add = lambda x, y: x + y
add(1, 2)
```

- lambda 함수는 함수의 인자로 사용할 수 있다.

```python
def my_function(func, x, y):
    return func(x, y)

my_function(lambda x, y: x + y, 1, 2)
```

# 함수형 프로그래밍
- 함수를 조합해서 프로그래밍하는 것
- 함수형 프로그래밍은 순수 함수를 사용한다.
- 순수 함수 : 함수의 입력 값이 같으면 항상 같은 출력 값을 반환하는 함수
- 반복문 대신 재귀 함수를 사용한다.
- 함수를 변수에 할당하거나 함수의 인자로 사용할 수 있다.
- 함수를 return 값으로 사용할 수 있다.
- 함수형 프로그래밍은 병렬처리가 쉽다.

### list comprehension
- 리스트를 생성하는 방법
- 리스트를 생성하는 방법을 간결하게 표현할 수 있다.
- list = [표현식 for 변수 in iterable]
- list = [표현식 for 변수 in iterable if 조건식]
- list = [표현식 if 조건식 else 표현식 for 변수 in iterable]
- ... 등등


```python
list = [ i in i for range(10) ]
list = [ i * 2 for i in list for i > 5 in list ]
```

```python
list = list(map(lambda x: x * 2, list))
list = list(filter(lambda x: x > 5, list))
```

# 객체지향 프로그래밍
- 객체를 생성하고 객체 간의 상호작용으로 프로그래밍하는 것
- 객체 : 속성과 메서드를 가지고 있는 것
- 클래스 : 객체를 생성하기 위한 설계도
- 객체지향 프로그래밍은 코드의 재사용성이 높다.
- 객체지향 프로그래밍은 유지보수가 쉽다.
  
---


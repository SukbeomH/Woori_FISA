# DELIMITER 

> 일반적으로 SQL Query는 끝에 세미콜론(`;`)을 붙여서 사용하는데, 
> *스토어드 프로시저를 작성할 때는 세미콜론을 사용할 수 없다.* 
> 그래서 `DELIMITER`를 사용하여 **구분자를 변경**해주어야 한다.

```sql
DELIMITER ~ -- 구분자를 ~로 변경, 이외에 다른 문자도 사용 가능
CREATE PROCEDURE 프로시저이름()
BEGIN
  SQL문1;
  SQL문2;
  ...
END ~ -- 변경된 ~로 끝을 표시
DELIMITER ; -- 구분자를 ;로 변경
```

- `DELIMITER`를 사용하여 구분자를 변경하면,
  -  `;`를 사용하여 SQL문을 구분할 수 없다. 
  -  그래서 `DELIMITER`로 변경한 구분자로 SQL문을 끝내야 한다.

만약 Delimiter를 설정하지 않으면 문장을 구분하기가 어렵기 때문에
위와 같이 Delimiter를 세미콜론이 아닌 ~로 설정한 것.

또한 마지막에 Delimiter 명령어를 다시 사용한 이유는 다시 세미콜론을 이용하여 문장을 구분하기 위해서이며 **Procedure 정의에 필수적인 요소는 아니다.**

---

# TRIGGER

> 트리거는 데이터베이스에서 특정 이벤트가 발생했을 때 자동으로 실행되는 일련의 SQL문이다.
> 제약 조건을 설정하는 데에도 사용되며, 데이터의 무결성을 유지하는 데에도 사용된다. (ex. 데이터의 삽입, 수정, 삭제)

- `CASCADE` : 참조 무결성 제약 조건을 설정할 때 사용되는 옵션으로, 참조되는 테이블의 데이터를 자동으로 삭제하거나 수정하는 옵션이다.
  - `ON DELETE CASCADE` : 참조되는 테이블의 데이터를 삭제할 때, 참조하는 테이블의 데이터도 자동으로 삭제한다.
  - 이러한 옵션들도 트리거를 통해 구현된다.

```sql
DELIMITER $$

	CREATE TRIGGER 트리거명
    BEFORE | AFTER -- 트리거가 실행되는 시점
      INSERT | UPDATE | DELETE -- 트리거가 실행되는 이벤트
        ON 테이블 FOR EACH ROW -- 테이블의 각 행마다 트리거가 실행되도록 설정
	BEGIN
    SQL문1; -- 트리거가 실행될 때 실행되는 SQL문1
    SQL문2; -- 트리거가 실행될 때 실행되는 SQL문2
	END $$    

DELIMITER ;
```

- `BEFORE` : 트리거가 실행되기 전에 실행되는 시점
- `AFTER` : 트리거가 실행된 후에 실행되는 시점
- `INSERT` : 데이터를 삽입할 때 트리거가 실행되는 이벤트
- `UPDATE` : 데이터를 수정할 때 트리거가 실행되는 이벤트
- `DELETE` : 데이터를 삭제할 때 트리거가 실행되는 이벤트
- `FOR EACH ROW` : 테이블의 각 행마다 트리거가 실행되도록 설정
  - 이 옵션을 사용하지 않으면 트리거가 한 번만 실행된다.
  - `FOR EACH ROW`를 사용하면 테이블의 각 행마다 트리거가 실행된다.
- `BEGIN`과 `END` 사이에 트리거가 실행될 때 실행되는 SQL문을 작성한다.

---

# PARTITION

> 파티션은 대용량의 데이터를 관리하기 위해 데이터를 분할하는 기법이다.
> 파티션을 사용하면 데이터를 논리적으로 분할하여 저장할 수 있으며, 데이터를 빠르게 검색할 수 있다.

- 파티션은 **테이블을 여러 개의 논리적인 단위로 분할**하는 것이다.
  - 테이블을 만들 때 파티션을 설정하면, 테이블의 데이터를 여러 개의 논리적인 단위로 분할하여 저장할 수 있다.

## 파티션 종류

- **RANGE 파티션**
  - 특정 범위의 값을 기준으로 데이터를 분할
  - ex) 날짜 범위, 숫자 범위 등.

- **LIST 파티션**
  - 특정 값 목록을 기준으로 데이터를 분할
  - ex) 특정 지역 코드, 상태 코드 등.

- **HASH 파티션**
  - 해시 함수를 사용하여 데이터를 균등하게 분할
  - ex) 특정 열의 해시 값을 기준으로 분할.

- **KEY 파티션**
  - MySQL의 내부 해시 함수를 사용하여 데이터를 분할
  - HASH 파티션과 유사하지만, MySQL이 해시 함수를 자동으로 선택

## 파티션의 장점
- 성능 향상: **특정 파티션만 스캔하여 쿼리 성능을 향상**시킬 수 있다.
- **관리 용이성:** 데이터 삭제, 백업, 복구 작업이 더 쉬워진다.
- **병렬 처리:** 여러 파티션에서 동시에 작업을 수행할 수 있다.

## 파티션의 단점
- 테이블 **설계와 관리가 더 복잡**해질 수 있다.
- 파티션 키를 신중하게 선택해야 한다.
  - 잘못된 선택은 **성능 저하를 초래할 수** 있다. 
- 외래 키 제약 조건을 사용할 수 없다. 
- 파티션된 테이블은 인덱스와 메타데이터를 각 파티션마다 유지해야 하므로 디스크 공간 사용이 증가할 수 있다.

```sql
CREATE TABLE 테이블명 (
  열1 데이터형,
  열2 데이터형,
  ...
)

PARTITION BY RANGE(열)
(
  PARTITION 파티션명1 VALUES LESS THAN (값),
  PARTITION 파티션명2 VALUES LESS THAN (값),
  ...
)
```

- `PARTITION BY RANGE(열)` : RANGE 파티션을 설정하는 구문
- `PARTITION 파티션명1 VALUES 조건` : 파티션을 설정하는 구문

### **SELECT 문을 사용하여 파티션을 확인할 수 있다.**

```sql
SELECT * FROM information_schema.partitions WHERE table_name = '테이블명';
```

- `information_schema.partitions` : 파티션 정보를 확인할 수 있는 시스템 테이블
- `table_name = '테이블명'` : 특정 테이블의 파티션 정보를 확인

```sql
SELECT 칼럼명 FROM 테이블명 WHERE 파티션조건;
```

- 일반적인 **SELECT 문과 동일하게** 사용할 수 있다.
- 파티션 조건을 추가하여 특정 파티션의 데이터를 조회할 수 있다.
  - 파티션 조건을 추가하지 않으면 모든 파티션의 데이터를 조회한다.
- 파티션 조건은 **파티션 설정 시 지정한 조건**을 사용한다.




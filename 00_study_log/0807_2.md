# 셸과 커널을 분리

> ‘한 프로그램에 너무 많은 기능을 넣지 않는다’

**리눅스의 기본 철학**이며, 한 프로그램에 기능을 많이 넣기보다 적절히 분리하는 설계 철학이 바탕이다.
    
- 셸과 커널을 분리하면 **커널을 바꾸지 않고 셸만 바꿀 수 있다**
  - 리눅스 외 OS(FreeBSD, NetBSD, Solaris 등)를 사용할 때도 *별도의 설치나 설정 없이도 셸만 이식하면 똑같이 사용* 할 수 있다. 
  - 셸을 사용하면서 에러가 발생하거나 지나치게 높은 부하가 발생해도 본체인 리눅스 커널에 미치는 **영향을 최소한으로** 줄일 수 있다.

## 별도의 설치나 설정 없이도 셸만 이식하면 똑같이 사용?

- 리눅스 커널은 **POSIX 표준**을 준수하므로, POSIX 표준을 준수하는 셸을 사용하면 리눅스 외의 다른 OS에서도 똑같이 사용할 수 있다.

**DOCKER** 등의 컨테이너 기술을 사용하면, 리눅스 커널을 포함한 전체 OS를 쉽게 이식할 수 있다.
- 도커의 가상화 기술도 쉘과 커널이 분리되어 있기 때문에 가능하다.
  - 도커는 **리눅스 커널을 공유**하면서, 컨테이너마다 **셸만 분리해서 사용**한다.

## 셸과 커널을 분리하는 이유

- **셸**: 사용자와 커널 사이의 중계 역할
  - 사용자의 명령을 해석하고, 커널에 명령을 전달한다.
- **커널**: 하드웨어와 소프트웨어 사이의 중계 역할
  - 하드웨어와 소프트웨어 사이의 인터페이스 역할을 한다.
- **셸과 커널을 분리**하면, **셸만 바꿔도 커널을 바꾸지 않고 사용**할 수 있다.

## 사용자별 표시

- **root**: `#`
- **일반 사용자**: `$`

셸을 사용할 때, **root 권한**으로 사용하면 `$` 대신 `#`이 표시된다.

## 셸의 종류

- **sh**: Bourne Shell
- **bash**: Bourne Again Shell
- **csh**: C Shell
- **tcsh**: Tenex C Shell
- **ksh**: Korn Shell
- **zsh**: Z Shell
- **fish**: Friendly Interactive Shell
- **dash**: Debian Almquist Shell
- **ash**: Almquist Shell

끝도 없이 많은 셸이 존재하지만, **bash**가 가장 많이 사용된다.
커스텀하는 사람들은 zsh나 fish를 사용하기도 한다.

# 리눅스의 종류

- **Red Hat 계열**: CentOS, Fedora, RHEL
- **Debian 계열**: Ubuntu, Debian
- **SUSE 계열**: openSUSE, SLES
- **Slackware 계열**: Slackware
- **Gentoo 계열**: Gentoo
- **Arch 계열**: Arch Linux
- **기타**: Mint, Elementary OS, Kali Linux 등

리눅스 커널은 같지만, **배포판에 따라 셸이나 패키지 관리자 등이 다르다**.

# 터미널

- 터미널이란 컴퓨터의 입출력만을 담당하는 전용 하드웨어를 의미한다.
  - 입력 장치인 키보드와 출력 장치인 모니터로 구성되어 있다.
  - 데이터 센터에는 간혹 입출력 기능만 갖춘 간이 단말기(dumb terminal)가 있기도 하다는 듯? (하드웨어 터미널)
- 일반적으로 소프트웨어로 구현한 터미널 에뮬레이터가 사용된다. 
  - **터미널 에뮬레이터는 리눅스, 윈도, 맥 등에서 애플리케이션으로 동작**

- **터미널 에뮬레이터와 셸은 완전히 다른 소프트웨어.**
  - 윈도에서 리눅스로 원격 로그인하면 터미널 에뮬레이터는 윈도 머신에서 작동
  - **셸은 리눅스 머신에서 돌아간다.**

# 유용한 명령어

## **`grep`** (글로벌 정규 표현식 출력)

파일 또는 출력에서 특정 패턴을 검색하는 명령어
**`$ grep "search_term" file.txt`**
        
  ```jsx
  ps -ef
  ps -ef|grep ssh
  grep man /etc/passwd # 문자열 그대로
  grep -i man /etc/passwd # 대소문자 구분 없이
  grep -v man /etc/passwd # 해당 문자열이 들어있지 않은 경우-반대되는 경우만 검색
  cat /etc/passwd|grep nologin  # 시스템이 사용하는 계정을 출력
  cat /etc/passwd|grep -v nologin  # 사람이 로그인하고 있는 계정을 출력
  grep -e 검색어1 -e 검색어2 -e 검색어3 # 여러개 검색어 사용해서 검색
  ```

## **`find`** (파일 찾기)

- **`find [경로] [옵션] [패턴]`**
- **`find / -name "file_name"`**: 루트 디렉토리부터 파일 찾기

  ```jsx
  find / -name "file_name"
  find / -name "file_name" 2>/dev/null # 에러 메시지 무시
  find / -name "file_name" 2>/dev/null -print # 에러 메시지 무시하고 파일 경로 출력
  find / -name "file_name" 2>/dev/null -print -exec ls -l {} \; # 에러 메시지 무시하고 파일 경로 출력하고 ls -l 명령어 실행
  find / -name "file_name" 2>/dev/null -print -exec ls -l {} \; | less # 에러 메시지 무시하고 파일 경로 출력하고 ls -l 명령어 실행하고 less로 출력
  ```

## **`locate`** (파일 찾기)

- **`locate [패턴]`**
- **`locate file_name`**: 파일 이름으로 파일 찾기
- **`updatedb`**: locate 명령어는 updatedb 명령어로 데이터베이스를 업데이트해야 한다.

  ```jsx
  locate file_name
  locate file_name | less
  ```

## **`which`** (명령어 위치 찾기)

- **`which [명령어]`**
- **`which ls`**: ls 명령어의 위치 찾기

  ```jsx
  which ls
  ```

## **`whereis`** (명령어 위치 찾기)

- **`whereis [명령어]`**
- **`whereis ls`**: ls 명령어의 위치 찾기

  ```jsx
  whereis ls
  ```
## 특정 포트 점유한 프로세스 확인

- **`lsof -i :포트번호`**
- **`lsof -i :80`**: 80번 포트를 점유한 프로세스 확인

  ```jsx
  lsof -i :80
  ```

등등

# adduser vs useradd

- **`adduser`**: 사용자 추가 명령어
  - 사용자 추가 시, 홈 디렉토리 생성, 사용자 계정 생성, 사용자 그룹 생성 등을 전부 처리
  - 사용자 추가 시, 사용자 계정 생성, 사용자 그룹 생성, 홈 디렉토리 생성, 기본 셸 설정, 사용자 정보 입력 등을 한번에 처리

- **`useradd`**: 사용자 추가 명령어
  - 보통 프로그램이 사용할 사용자를 추가할 때 사용
  - 사용자 추가 시, 사용자 계정 **생성만** 처리
  - Home 디렉토리 생성, 사용자 그룹 생성, 기본 셸 설정, 사용자 정보 입력 등을 따로 처리해야 함 **(기본적으로 생기지 않는다)**

## deluser vs userdel

- **`deluser`** 
  - 사용자 삭제 시, 사용자 계정 삭제, 사용자 그룹 삭제, 홈 디렉토리 삭제 등을 한번에 처리(--remove-home 옵션 사용 시, 홈 디렉토리 삭제)
- **`userdel`**
  - 사용자 삭제 시, 사용자 계정 삭제만 처리
  - 사용자 계정 삭제 후, 사용자 그룹 삭제, 홈 디렉토리 삭제 등을 따로 처리해야 함

# 리눅스 명령어

- **`ls`**: 디렉토리 목록 출력
- **`cd`**: 디렉토리 변경
- **`pwd`**: 현재 디렉토리 출력
- **`mkdir`**: 디렉토리 생성
- **`rmdir`**: 디렉토리 삭제
- **`cp`**: 파일 복사
- **`mv`**: 파일 이동
- **`rm`**: 파일 삭제
- **`cat`**: 파일 내용 출력

## cp (파일 복사)

- **`cp [옵션] [소스] [타겟]`**
  - **`-r`**: 디렉토리 복사
  - **`-i`**: 덮어쓰기 여부 확인
  - **`-f`**: 덮어쓰기 여부 묻지 않음
  - **`-v`**: 복사 과정 출력

```bash
  cp file1 file2
  cp -r dir1 dir2
  cp -iv file1 file2
```

## mv (파일 이동)

- **`mv [옵션] [소스] [타겟]`**
  - **`-i`**: 덮어쓰기 여부 확인
  - **`-f`**: 덮어쓰기 여부 묻지 않음
  - **`-v`**: 이동 과정 출력

```bash
  mv file1 file2
  mv -i file1 file2
```

## cat (파일 내용 출력)

- **`cat [파일]`**
  - **`-n`**: 줄 번호 출력
  - **`-b`**: 빈 줄은 출력하지 않음
- **`cat file1 file2`**: 파일1과 파일2를 이어 붙여서 출력

```bash
  cat file1
  cat -n file1
  cat -b file1
  cat file1 file2
```

사실 `concatenate`의 줄임말이다. (이어붙이다)

USE fisa;

-- 스칼라 서브쿼리 : 결과가 하나의 값으로 도출
-- 내부쿼리 -> 외부쿼리 동작
-- 내부쿼리에서는 외부쿼리의 FROM 절에 사용한 테이블을 참조할 수 있다
-- 외부쿼리에서는 내부쿼리에서 사용한 테이블을 참조할 수 없다
-- SELECT 절에는 스칼라 서브쿼리만 쓸 수 있습니다. 



-- 2. FROM 절에서의 서브쿼리
-- 파생(derived) 서브쿼리
-- 꼭 별칭을 붙여서 외부 쿼리문에서는 별칭으로 사용합니다.
-- 서브쿼리가 반환하는 결과 집합을 하나의 테이블처럼 사용하는 쿼리문
-- 서브쿼리 안에서 사용해도 된다 
-- FROM -> WHERE -> SELECT 

SELECT b.deptno, b.empno, c.ename
					  FROM emp b,
					       emp c
					 WHERE b.empno = c.empno;

SELECT a.deptno, a.dname
  FROM dept a
 ORDER BY 1;
                     
 -- join으로 해결
 -- emp 테이블에서 SMITH 직원명 검색해서 
 -- 어떤 부서인지 dept 테이블에서 찾아서 출력하기
 

-- 3. WHERE절의 서브쿼리
-- - 특정 데이터를 걸러내기 위한 일반 조건이나 조회 조건을 기술 
-- 비교 연산자 또는 ANY(~ 중 하나), SOME(하나라도 있으면), ALL(모두) 연산자를 사용하기도 함

  SELECT e.ename
   FROM emp e
    WHERE e.ename='SMITH';

 SELECT d.dname
FROM dept d
WHERE d.deptno=????;

 -- subquery로 해결
 

-- SMITH씨와 동일한 RESEARCH 부서 가진 모든 사원의 이름을 출력해보세요


use fisa;



-- ANY, SOME, ALL 이라는 조건을 사용해서 여러개의 결과값과 비교를 할 수도 있습니다.
-- ANY, SOME : 서브쿼리의 결과값 중 하나라도 만족하면 참
-- ALL : 서브쿼리의 결과값 모두 만족해야 참


-- SMITH 씨랑 급여가 같거나 더 많은 사원명과 급여를 검색해주세요


-- 급여가 3000불 이상인 사원이 소속된 부서(10, 20)에 속한 사원이름, 급여 검색



-- EXISTS 연산자는 메인쿼리 테이블의 값 중에서 서브쿼리의 결과 집합에
-- 존재하는 건이 있는지를 확인하는 역할

-- EXISTS                  
-- 서브쿼리의 결과값이 존재하면 참

-- 각 부서별로 SAL가 가장 높은 사람은 누구일까요? 
-- 서브쿼리에 group by를 사용할 수 있다 
				  -- group by로는 볼 수 없던 행별 정보를 서브쿼리로 추출한 테이블로 필터링해서 꺼낼 수 있다 


-- IN 연산자는 여러개 컬럼의 값을 비교해서 꺼낼 수 있습니다
-- 단 순서가 맞아야 합니다 


-- job이 매니저인 사람이 어느 부서에만 있는지 서브쿼리를 통해 확인해보세요 


-- 실습

-- 2018년에 가장 많은 매출을 기록한 영화보다 더 많은 매출을 기록한 2019년도 영화를 검색해주세요    


-- 2019년에 개봉한 영화 중 2018년에는 개봉하지 않았던 영화의 순위, 영화명, 감독을 검색해주세요


-- 2018년에도 개봉했고, 2019년에 다시 개봉한 영화의 순위, 영화명, 감독을 검색해주세요.




-- FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT
-- 행이 많으면 속도가 느려지기 때문에 가장 행을 앞단에서 줄일 수 있는 순서
-- 테이블은 메인쿼리에서 먼저 가져옵니다 
-- 여기에 더해서 서브쿼리가 먼저 동작하기 때문에 서브쿼리를 최대한 간소한 결과가 나오도록 작성해주시면 좋습니다 

                       
-- 어차피 동작도 서브쿼리부터 하고, 서브쿼리가 길어서 뭘 하는지 안 보인다면 
-- 따로 빼줘도 좋지 않을까요 
-- CTE, Common Table Expression FROM 절에서는 사용하기 위한 파생 테이블의 별명을 붙여서 사용할 수 있습니다 
USE fisa;
WITH mgr AS (SELECT b.deptno, b.empno, c.ename
					  FROM emp b, emp c
					 WHERE b.empno = c.empno
       )  -- AS 뒤에 있는 쿼리로 만들어진 테이블을 메인쿼리에서 mgr이라고 부르겠다 
       
SELECT a.deptno, a.dname, mgr.empno
  FROM dept a, mgr -- mgr이라고 부르고 있습니다 
 WHERE a.deptno = mgr.deptno
 ORDER BY 1;
 
 
 
use fisa;

-- CTE는 FROM 절에서만 쓸 수 있다 


## SQL 실행순서
-- FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT

-- 모든 부서의 정보와 함께 커미션이 있는 직원들의 커미션과 이름을 조회해 보세요.

-- 모든 부서의 부서별 연봉에 대한 총합과 평균과 표준편차를 구하고
-- 모든 부서의 사원수를 구해 보세요.

-- 각 관리자의 부하직원수와 부하직원들의 평균연봉을 구해 보세요.

# Sub-Query 
-- 쿼리 안쪽에 쿼리를 넣을수 있다.
-- where 절에서의 서브쿼리
-- scott과 같은 부서에 있는 직원 이름을 검색해 보세요.

-- 직무(job)가 Manager인 사람들이 속한 부서의 부서번호와 부서명 , 지역을 조회해 보세요.
	-- manager 사람들이 다수이기 때문에 where절에 in 을 활용!

# from 절에서의 서브쿼리
-- emp 테이블에서 급여가 2000이 넘는 사람들의 이름과 부서번호, 부서이름, 지역 조회해 보세요.

-- emp 테이블에서 커미션이 있는 사람들의 이름과 부서번호, 부서이름, 지역을 조회해 보세요.

-- join 절에서의 서브쿼리

-- 모든 부서의 부서이름과, 지역, 부서내의 평균 급여를 조회해 보세요.